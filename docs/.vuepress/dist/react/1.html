<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React中的类 | Insomnia&#39;s Blog</title>
    <meta name="description" content="前端技术小结">
    <meta name="generator" content="VuePress 1.3.1">
    <link rel="icon" href="/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.24d7f512.css" as="style"><link rel="preload" href="/assets/js/app.32b5a6ef.js" as="script"><link rel="preload" href="/assets/js/2.9aa5139d.js" as="script"><link rel="preload" href="/assets/js/10.ea992c54.js" as="script"><link rel="prefetch" href="/assets/js/11.79fa7426.js"><link rel="prefetch" href="/assets/js/12.ecc788b6.js"><link rel="prefetch" href="/assets/js/3.7607fff1.js"><link rel="prefetch" href="/assets/js/4.5f96f5bb.js"><link rel="prefetch" href="/assets/js/5.46a36351.js"><link rel="prefetch" href="/assets/js/6.8b4fda01.js"><link rel="prefetch" href="/assets/js/7.efc36d86.js"><link rel="prefetch" href="/assets/js/8.8f49f68f.js"><link rel="prefetch" href="/assets/js/9.d8a80012.js">
    <link rel="stylesheet" href="/assets/css/0.styles.24d7f512.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Insomnia's Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>React</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/react/1.html" class="active sidebar-link">React中的类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react/1.html#reactelement：节点类" class="sidebar-link">ReactElement：节点类</a></li><li class="sidebar-sub-header"><a href="/react/1.html#reactcomponent：外部组件类" class="sidebar-link">ReactComponent：外部组件类</a></li><li class="sidebar-sub-header"><a href="/react/1.html#reactcompositecomponent：内部组件类" class="sidebar-link">ReactCompositeComponent：内部组件类</a></li><li class="sidebar-sub-header"><a href="/react/1.html#reactnativebasecomponent：rn中映射到native的组件类" class="sidebar-link">ReactNativeBaseComponent：RN中映射到Native的组件类</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Notes</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>看了一段时间React源码，主要是React Native实现的Virtual Dom树渲染更新部分。React版本是15.2.1，React Native版本是0.30.0。
自己的第一个系列博客，梳理巩固所思所得。如果能对你有所助益，是更吼的了。</p> <p>React实现了一套由数据到展示的渲染更新方案。数据存放在一个个节点中，最终的展示由节点组成的树决定。任何展示的更新都来源于数据的更新，即props或state的更新。
</p> <hr> <h2 id="reactelement：节点类"><a href="#reactelement：节点类" class="header-anchor">#</a> ReactElement：节点类</h2> <p>数据节点，以后简称element，存储了type、key、ref、props等内容。</p> <p>render的作用就是生成element，是渲染的第一站。element保存了props而并没有state，因为state会在render方法内作为某个element的props存储在element中。</p> <hr> <h2 id="reactcomponent：外部组件类"><a href="#reactcomponent：外部组件类" class="header-anchor">#</a> ReactComponent：外部组件类</h2> <p>开发中定义组件所写的类。“外部”可以理解为由开发人员使用的，相对的“内部”是指React内部实现渲染更新而使用的。其实例称为publicInstance。</p> <p>可分为继承于React.Component的组件、纯函数组件两种。两者都实现了render方法，所以程序中任意界面无论多复杂，总能通过层层嵌套生成各级element。不同的是前者可维护state，并具备相应生命周期，这些定义将作用于React内部执行渲染更新。</p> <p>ReactComponent具备setState和forState两个方法，两个方法的本质是在内部调用updater的相关方法压入待更新组件（在ReactUpdateQueue中详细介绍）。</p> <p><em>注释：React中ReactComponent特指React.Component，我们这里把纯函数也算作一个特殊的ReactComponent，即外部组件类，便于后续理解。</em></p> <h3 id="总结为三点主要作用："><a href="#总结为三点主要作用：" class="header-anchor">#</a> 总结为三点主要作用：</h3> <ol><li>描述了渲染的树结构</li> <li>维护了state</li> <li>解释了在生命周期或事件触发时希望执行的内容</li></ol> <hr> <h2 id="reactcompositecomponent：内部组件类"><a href="#reactcompositecomponent：内部组件类" class="header-anchor">#</a> ReactCompositeComponent：内部组件类</h2> <p>React内部真正管理组件渲染和更新的类（手动划重点）。其实例为internalInstance的一种。</p> <p>在RN中internalInstance有两种，分别是ReactCompositeComponent和ReactNativeBaseComponent的实例。</p> <p>一个节点通常会经历挂载、更新、卸载三个生命阶段。节点树上的element，若其type是ReactComponent，则会在挂载时转化为ReactCompositeComponent实例。</p> <p>实现了挂载、更新、卸载的方法，并负责在合适的时机触发生命周期方法。</p> <h3 id="挂载：mountcomponent"><a href="#挂载：mountcomponent" class="header-anchor">#</a> 挂载：mountComponent</h3> <p>返回值为markup，即本节点渲染的内容，在RN中是与Native渲染的真实View关联的一个ID。</p> <ol><li>生成ReactComponent的实例，存放于_instance。</li> <li>执行componentWillMount</li> <li>执行render获得一个element，存放于_renderedElement，根据element获得对应的internalInstance，存放于_renderedComponent，继续对其执行mountComponent，这样就完成了一次挂载过程中的向下解析。直至internalInstance是ReactNativeBaseComponent，就获得了与Native真实View关联的ID，作为markup递归返回。</li> <li>将componentDidMount压入待执行队列</li></ol> <h3 id="更新：updatecomponent"><a href="#更新：updatecomponent" class="header-anchor">#</a> 更新：updateComponent</h3> <ol><li>判断context更改或element的不同，触发componentWillReceiveProps。（props变化伴随着新element）</li> <li>通过_pendingForceUpdate和shouldComponentUpdate决定是否更新。若更新，执行以下：</li> <li>执行componentWillUpdate</li> <li>执行render获得一个element，与之前的_renderedElement对比是否可以通过在旧组件上更新完成变动</li> <li>若可以，对_renderedComponent继续执行updateComponent，完成了一次更新过程中的向下解析。</li> <li>若不可以，卸载旧_renderedComponent，根据element实例化并挂载新的_renderedComponent，使用其返回的Markup对旧的进行替换</li></ol> <h3 id="卸载：unmountcomponent"><a href="#卸载：unmountcomponent" class="header-anchor">#</a> 卸载：unmountComponent</h3> <ol><li>执行componentWillUnmount</li> <li>对_renderedComponent继续unmountComponent，完成了一次卸载过程中的向下解析。</li> <li>清空存储的各种5数据</li></ol> <hr> <h2 id="reactnativebasecomponent：rn中映射到native的组件类"><a href="#reactnativebasecomponent：rn中映射到native的组件类" class="header-anchor">#</a> ReactNativeBaseComponent：RN中映射到Native的组件类</h2> <p>真正会被Native渲染的组件类，通过UIManager将渲染内容传递给Native绘制。其实例为internalInstance的一种。</p> <p>在RN中，所有的children的父节点都是ReactNativeBaseComponent（重点，理解树结构是如何解析的）。</p> <p>实现了挂载、更新、卸载的方法，通过UIManager操作Native的UI，向下处理children的解析。</p> <h3 id="挂载：mountcomponent-2"><a href="#挂载：mountcomponent-2" class="header-anchor">#</a> 挂载：mountComponent</h3> <p>返回值为tag，与RN中真实的View关联。</p> <ol><li>UIManager.createView，通过tag关联创建Native的View，tag存储在_rootNodeID。</li> <li>遍历children执行mountComponent，获得markup的数组(createTags)，UIManager.setChildren(containerTag, createTags)管tag关联，实现了Native中View的关联。</li></ol> <h3 id="更新：updatechildren"><a href="#更新：updatechildren" class="header-anchor">#</a> 更新：updateChildren</h3> <ol><li>比较前后children里的element，对保留的旧节点执行updateComponent。</li> <li>产生三种更新操作：移动（已有）、删除、插入（新建），并通过UIManager.manageChildren执行更新</li></ol> <h3 id="卸载：unmountcomponent-2"><a href="#卸载：unmountcomponent-2" class="header-anchor">#</a> 卸载：unmountComponent</h3> <ol><li>遍历children执行unmountComponent</li></ol> <hr> <p>本节介绍了React中的几个基础类的概念，下节将它们串联起来。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/notes/passive-check.html">
        检测浏览器是否支持passive event listener
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.32b5a6ef.js" defer></script><script src="/assets/js/2.9aa5139d.js" defer></script><script src="/assets/js/10.ea992c54.js" defer></script>
  </body>
</html>
